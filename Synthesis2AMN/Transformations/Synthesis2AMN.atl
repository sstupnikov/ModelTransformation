-- @path AMN=/ATL%20Transformations/Metamodels/AMN.ecore
-- @path Synthesis=/ATL%20Transformations/Metamodels/Synthesis.ecore

-- The transformation is Atelier B compatible

module Sunthesis2AMN;
create OUT : AMN from IN : Synthesis;

uses AMN2String;
-----------------------
-- GLOBAL VARIABLES
-----------------------

helper def: pathVars: Map(Synthesis!Predicative, Map(String, Integer)) =
	Map{}
;

-----------------------
-- RULES
-----------------------

rule Module2Context{
	from m: Synthesis!ModuleDef
	using{
		adts0: Set(Synthesis!ADTDef) = m.containedTypes->select(t | t.oclIsKindOf(Synthesis!ADTDef));
		adts1: Set(Synthesis!ADTDef) = m.containedTypes->select(t | t.oclIsKindOf(Synthesis!ADTDef));
	}
	to ctxt: AMN!AbstractMachine(
			name <- m.contextMachineName,
			sets              <- Sequence{avalSet, oidSet}, 
			abstractConstants <- Sequence{'Obj', 'self'},
			properties <- Sequence{objProp, selfProp}		
		),
		avalSet: AMN!SetDecl(name <- 'AVAL'),
		oidSet: AMN!SetDecl(name <- 'OID'),		

		-- Object set typing
		objProp : AMN!AtomicPredicate (
			sign <- ':',
			expression <- Sequence{objConst, objType}
		),
		objConst : AMN!NamedConstant(name <- 'Obj'),
		objType : AMN!FunctionalExpression (
			sign <- 'POW',
			expression <- aval			
		),
		aval: AMN!NamedConstant(name <- 'AVAL'),		
		
		-- Self constant typing
		selfProp: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{selfConst, selfType}
		),
		selfConst: AMN!NamedConstant(name <- 'self'),				
		selfType: AMN!BinaryOperator (
			sign <- '>->>',
			expression <- Sequence{objConst1, oid}			
		),
		objConst1: AMN!NamedConstant(name <- 'Obj'),
		oid: AMN!NamedConstant(name <- 'OID')	
	do{
		
		-- Add extent constants and properties to context machine 
		for(adt in adts0){
			ctxt.abstractConstants <- Sequence{'extp_' + adt.name.amnId, 'ext_' + adt.name.amnId};	
			ctxt.properties <- 
				Sequence{
					thisModule.resolveTemp(adt, 'ownExtTyp'), 
					thisModule.resolveTemp(adt, 'fullExtTyp'), 
					thisModule.resolveTemp(adt, 'ownFullExtRel')
				};
		}		
		
		-- Put empty extent intersection properties to context	
		for(t0 in adts0){
			adts1 <- adts1->excluding(t0); 
			for(t1 in adts1){
				thisModule.PutEmptyIntersectOfExtentsToContext(t0, t1);
			}
		}				
	}
			
}

-- Empty intersection of ADT's own extents predicate
rule PutEmptyIntersectOfExtentsToContext(t1: Synthesis!ADT, t2: Synthesis!ADT){
	to		 
		ownExtentsEmptyIntersect: AMN!AtomicPredicate (
			sign <- '=',
			expression <- ownExtentsIntersect,
			expression <- emptySet
		),
		ownExtentsIntersect: AMN!BinaryOperator (
			sign <- '/\\',
			expression <- Sequence{ext_t1, ext_t2}
		),
		ext_t1: AMN!NamedConstant(name <- 'extp_' + t1.name.amnId),
		ext_t2: AMN!NamedConstant(name <- 'extp_' + t2.name.amnId),
		emptySet: AMN!SetValue()	
	do{
		thisModule.resolveTemp(t1.typeInModule, 'ctxt').properties <- ownExtentsEmptyIntersect;
	}
}

-- For object ADT
rule ADT{
	from adt: Synthesis!ADTDef(adt.nonobject = false)
	using{
		nonMethods: Set(Synthesis!AttributeDef) = adt.attributes->select(a | not a.type.oclIsKindOf(Synthesis!Predicative));
		methods: Set(Synthesis!AttributeDef) = adt.attributes->select(a | a.type.oclIsKindOf(Synthesis!FunctionDef));
		invs: Set(Synthesis!AttributeDef) = adt.attributes->select(a | a.type.oclIsKindOf(Synthesis!InvariantDef));

		classes: Set(Synthesis!ClassDef) = Synthesis!ClassDef.allInstances()->select(cl | cl.instanceType = adt);
	}
	to 	
		-- Machine with set-operations to be used for SEES, INCLUDES compositions
		am: AMN!AbstractMachine(
			name <- adt.name.amnId,
			sees <- thisModule.resolveTemp(adt.typeInModule, 'ctxt'),
			abstractVariables <- nonMethods->collect(a | a.name.amnId),
			invariant <- classes->collect(cl | thisModule.resolveTemp(cl, 'typingAM')),
			invariant <- nonMethods->iterate(attr; acc: Set(Synthesis!ClassDef) = Set{} | acc->union(attr.classes))->
				select(cls | cls.oclIsKindOf(Synthesis!AssociationMetaclassDef))->
				collect(cls | thisModule.resolveTemp(cls, 'invAM')),
			invariant <- nonMethods->collect(attr | thisModule.Attribute2Invariant(attr)),
			invariant <- nonMethods->select(attr | attr.hasCardinality)->collect(attr | thisModule.Attribute2CardinalityPredicate(attr)),
			invariant <- nonMethods->select(attr | not attr.inverseAttribute.oclIsUndefined())->collect(attr | thisModule.Attribute2InversePredicate(attr)),
			-- If adt is instance type of some association metaclass, then invariants are transformed by AssociationMetaclassVarEquality 
			invariant <- if not adt.isIstanceTypeOfAssociationMetaclass then invs->collect(attr | thisModule.LazyFormula(attr.type.predicativeSpec)) else Set{} endif,
			initialization <- nonMethods->collect(attr | thisModule.Attribute2Initialization(attr)), 
			operations <- nonMethods->collect(attr | thisModule.Attribute2SetOperation(attr))			
		),
		-- Machine with empty operation intended to be a refined machine for ref
		amEmptyOps: AMN!AbstractMachine(
			name <- 'M' + adt.name.amnId,
			sees <- thisModule.resolveTemp(adt.typeInModule, 'ctxt'),
			operations <- methods->collect(m | thisModule.resolveTemp(m, 'emptyBodyOperation'))
		),
		-- Refinement with operations-methods
		ref: AMN!Refinement(
			name <- adt.name.amnId + 'Ref',
			refines <- amEmptyOps,
			sees <- thisModule.resolveTemp(adt.typeInModule, 'ctxt'),
			abstractVariables <- nonMethods->collect(a | a.name.amnId),
			invariant <- classes->collect(cl | thisModule.resolveTemp(cl, 'typingRef')),
			invariant <- nonMethods->iterate(attr; acc: Set(Synthesis!ClassDef) = Set{} | acc->union(attr.classes))->
				select(cls | cls.oclIsKindOf(Synthesis!AssociationMetaclassDef))->
				collect(cls | thisModule.resolveTemp(cls, 'invRef')),			
			invariant <- nonMethods->collect(attr | thisModule.Attribute2Invariant(attr)),
			invariant <- nonMethods->select(attr | attr.hasCardinality)->collect(attr | thisModule.Attribute2CardinalityPredicate(attr)),
			invariant <- nonMethods->select(attr | not attr.inverseAttribute.oclIsUndefined())->collect(attr | thisModule.Attribute2InversePredicate(attr)),			
			invariant <- invs->collect(attr | attr.type.predicativeSpec),
			initialization <- nonMethods->collect(attr | thisModule.Attribute2Initialization(attr)),
			operations <- methods
		),
				
		-- Own extent typing
		ownExtTyp: AMN!AtomicPredicate (
			sign <- ':',
			expression <- extp0,
			expression <- powObj0
		),
		extp0: AMN!NamedConstant(name <- 'extp_' + adt.name.amnId),
		powObj0 : AMN!FunctionalExpression (
			sign <- 'POW',
			expression <- objConst0
		),		
		objConst0: AMN!NamedConstant(name <- 'Obj'),
		
		-- Full extent typing
		fullExtTyp : AMN!AtomicPredicate (
			sign <- ':',
			expression <- ext0,
			expression <- powObj1
		),
		ext0: AMN!NamedConstant(name <- 'ext_' + adt.name.amnId),		
		powObj1 : AMN!FunctionalExpression (
			sign <- 'POW',
			expression <- objConst1
		),		
		objConst1: AMN!NamedConstant(name <- 'Obj'),
		
		-- Own and full extents relationship
		ownFullExtRel : AMN!AtomicPredicate (
			sign <- '<:',
			expression <- extp1,
			expression <- ext1
		),
		extp1: AMN!NamedConstant(name <- 'extp_' + adt.name.amnId),
		ext1: AMN!NamedConstant(name <- 'ext_' + adt.name.amnId)	
	do{
		
		-- Supertype relationship mapping
		if(adt.supertypes->notEmpty()){
			for(e in adt.supertypes){			
				am.extendsClause <- thisModule.resolveTemp(e, 'am');
				ref.extendsClause <- thisModule.resolveTemp(e, 'am');
				thisModule.SubtypeRelation(e, adt);
			}
		}
				
	}		
}

rule SubtypeRelation(sup: Synthesis!ADTDef, sub: Synthesis!ADTDef){
	to
		rel: AMN!AtomicPredicate(
			sign <- '<<:',
			expression <- Sequence{subConst, supConst}			
		),
		supConst: AMN!NamedConstant(name <- 'ext_' + sup.name.amnId),
		subConst: AMN!NamedConstant(name <- 'ext_' + sub.name.amnId)
	do {
		thisModule.resolveTemp(sup.typeInModule, 'ctxt').properties <- rel;
	} 
}


rule Class{
	from 
		cls: Synthesis!ClassDef(cls.oclIsTypeOf(Synthesis!ClassDef))
	to
		-- Typing predicate and init to instance type abstract machine
		typingAM: AMN!AtomicPredicate (
			sign <- ':',
			expression <- varAM,
			expression <- varTypeAM
		),
		varAM: AMN!Variable(name <- cls.name.amnId),
		varTypeAM: AMN!FunctionalExpression (
			sign <- 'POW',
			expression <- extAM
		),
		extAM: AMN!NamedConstant(name <- 'ext_' + cls.instanceType.name.amnId),
		initAM: AMN!BecomesEqual(
			leftExpression <- varInitAM,
			rightExpression <- emrtySetAM
		),
		varInitAM: AMN!Variable(name <- cls.name.amnId),
		emrtySetAM: AMN!SetValue,
		
		-- Typing predicate and init to instance type refinement
		typingRef: AMN!AtomicPredicate (
			sign <- ':',
			expression <- varRef,
			expression <- varTypeRef
		),
		varRef: AMN!Variable(name <- cls.name.amnId),
		varTypeRef: AMN!FunctionalExpression (
			sign <- 'POW',
			expression <- extRef
		),
		extRef: AMN!NamedConstant(name <- 'ext_' + cls.instanceType.name.amnId),
		initRef: AMN!BecomesEqual(
			leftExpression <- varInitRef,
			rightExpression <- emrtySetRef
		),
		varInitRef: AMN!Variable(name <- cls.name.amnId),
		emrtySetRef: AMN!SetValue
		
	do {
		
		thisModule.resolveTemp(cls.instanceType,'am').abstractVariables <- cls.name.amnId;
		thisModule.resolveTemp(cls.instanceType, 'am').initialization <- initAM;
		
		thisModule.resolveTemp(cls.instanceType,'ref').abstractVariables <- cls.name.amnId;
		thisModule.resolveTemp(cls.instanceType, 'ref').initialization <- initRef;		
		
		-- Add subclass relations to type machine and refinement
		for(sup in cls.superclasses){
			thisModule.SubclassRelation(cls, sup);
			
			if(not thisModule.resolveTemp(cls.instanceType, 'am').extendsClause->includes(thisModule.resolveTemp(sup.instanceType, 'am'))){
				thisModule.resolveTemp(cls.instanceType, 'am').includes <- thisModule.resolveTemp(sup.instanceType, 'am');
				thisModule.resolveTemp(cls.instanceType, 'ref').includes <- thisModule.resolveTemp(sup.instanceType, 'am');
			}
		}
	}
}

-- Add subclass relations to type machine and refinement
rule SubclassRelation(sub: Synthesis!ClassDef, sup: Synthesis!ClassDef) {
	to
		-- Relation to instance type abstract machine
		relAM: AMN!AtomicPredicate (
			sign <- '<:',
			expression <- Sequence{subVarAM, supVarAM}			
		),
		subVarAM: AMN!Variable(name <- sub.name.amnId),
		supVarAM: AMN!Variable(name <- sup.name.amnId),
		
		-- Relation to instance type refinement
		relRef: AMN!AtomicPredicate (
			sign <- '<:',
			expression <- Sequence{subVarRef, supVarRef}			
		),
		subVarRef: AMN!Variable(name <- sub.name.amnId),
		supVarRef: AMN!Variable(name <- sup.name.amnId)		
	do {
		thisModule.resolveTemp(sub.instanceType, 'am').invariant <- relAM;
		thisModule.resolveTemp(sub.instanceType, 'ref').invariant <- relRef;
	}
}


-- Create a set in context for contained enum type of an attribute
rule EnumTypeAttribute{
	from attr: Synthesis!AttributeDef(attr.type.oclIsKindOf(Synthesis!EnumDef))
	using{
		enumName: String = attr.attributeOf.name.amnId + '_' + attr.name.amnId + '_' + 'Enum';
	}		
	to enum: AMN!SetDecl(
			name <- enumName,
			element <- attr.type.enumList->collect(e | e.amnId)
		)
	do{
		thisModule.resolveTemp(attr.attributeOf.typeInModule, 'ctxt').sets  <- enum;		
	}
}

lazy rule Attribute2Invariant{
	from attr: Synthesis!AttributeDef(not attr.type.oclIsKindOf(Synthesis!Predicative)) 
	to 	inv: AMN!Conjunction(
			predicate <- attrTyping
		),		
		attrTyping: AMN!AtomicPredicate(
			sign <- ':',
			expression <- attrVar,
			expression <- extFunc			
		),
		attrVar: AMN!NamedConstant(name <- attr.name.amnId),
		extFunc: AMN!BinaryOperator (
			sign <- '-->',
			expression <- extConst		
		),	
		extConst: AMN!NamedConstant(name <- 'ext_' + attr.attributeOf.name.amnId)
	do{
		thisModule.PutAttributeTypeToBinaryOperator(attr, extFunc);
		
		for(cls in attr.classes->select(mc | mc.oclIsKindOf(Synthesis!AssociationMetaclassDef))){
			thisModule.PutAttributeCategoryToCompoundPredicate(attr, cls, inv);
		}	
	}
}

rule PutAttributeTypeToBinaryOperator(attr: Synthesis!AttributeDef, bop: AMN!BinaryOperator){
	do{
		if(attr.type.oclIsKindOf(Synthesis!ADTDef))
			bop.expression <- thisModule.ADT_Typing(attr.type);
		else 
		if(attr.type.oclIsKindOf(Synthesis!IntegerDef))
			bop.expression <- thisModule.Integer_Typing(attr.type);
		else 
		if(attr.type.oclIsKindOf(Synthesis!BooleanDef))
			bop.expression <- thisModule.Boolean_Typing(attr.type);
		else 
		if(attr.type.oclIsKindOf(Synthesis!StringDef))
			bop.expression <- thisModule.String_Typing(attr.type);
		else 
		if(attr.type.oclIsKindOf(Synthesis!EnumDef))
			bop.expression <- thisModule.Enum_Typing(attr);		
		else 
		if(attr.type.oclIsKindOf(Synthesis!SetDef))
			bop.expression <- thisModule.Set_Typing(attr.type);						
	}
}

lazy rule ADT_Typing{
	from adt: Synthesis!ADTDef
	to 	const: AMN!NamedConstant(name <- 'ext_' + adt.name.amnId)
}

lazy rule Integer_Typing{
	from int: Synthesis!IntegerDef
	to 	const: AMN!NamedConstant(name <- 'INTEGER')
}

lazy rule Boolean_Typing{
	from bool: Synthesis!BooleanDef
	to 	const: AMN!NamedConstant(name <- 'BOOL')
}

lazy rule String_Typing{
	from str: Synthesis!StringDef
	to 	func: AMN!FunctionalExpression(
			sign <- 'seq',
			expression <- range
		),
		range: AMN!BinaryOperator(
			sign <- '..',
			expression <- Sequence{v_0, v_255}
		),
		v_0: AMN!IntegerValue(value <- 0),
		v_255: AMN!IntegerValue(value <- 255)
}

lazy rule Enum_Typing{
	from attr: Synthesis!AttributeDef(attr.type.oclIsKindOf(Synthesis!EnumDef))
	using{
		enumName: String = attr.attributeOf.name.amnId + '_' + attr.name.amnId + '_' + 'Enum';
	}	
	to 	const: AMN!NamedConstant(name <- enumName)
}

lazy rule Set_Typing{
	from set: Synthesis!SetDef
	to 	func: AMN!FunctionalExpression(
			sign <- 'POW'
		)
	do{
		if(set.ofType.oclIsKindOf(Synthesis!ADTDef))
			func.expression <- thisModule.ADT_Typing(set.ofType);
		else 
		if(set.ofType.oclIsKindOf(Synthesis!IntegerDef))
			func.expression <- thisModule.Integer_Typing(set.ofType);
		else 
		if(set.ofType.oclIsKindOf(Synthesis!BooleanDef))
			func.expression <- thisModule.Boolean_Typing(set.ofType);
		else 
		if(set.ofType.oclIsKindOf(Synthesis!StringDef))
			func.expression <- thisModule.String_Typing(set.ofType);
	}
}

lazy rule Attribute2SetOperation{
	from attr: Synthesis!AttributeDef(
			not attr.type.oclIsKindOf(Synthesis!Predicative) 
		 )
	to op: AMN!Operation(
			name <- 'set_' + attr.name.amnId,
			inputParams <- 'sav',
			substitution <- preSubst
		),
		preSubst: AMN!Precondition (
			pre <- predicate,
			thenPart <- beSubst
		),
		predicate: AMN!AtomicPredicate (
			sign <- ':',
			expression <- inpVar,
			expression <- inpVarType
		),
		inpVar: AMN!Variable(name <- 'sav'),
		inpVarType: AMN!BinaryOperator(
			sign <- '+->',
			expression <- ext			
		),
		ext: AMN!NamedConstant(name <- 'ext_' + attr.attributeOf.name.amnId),
		beSubst : AMN!BecomesEqual (
			leftExpression <- attrVar,
			rightExpression <- modAttrVar
		),
		attrVar: AMN!Variable(name <- attr.name.amnId),
		modAttrVar : AMN!BinaryOperator (
			sign <- '<+',
			expression <- Sequence{attrVar1, inpVar1}
		),
		attrVar1: AMN!Variable(name <- attr.name.amnId),
		inpVar1: AMN!Variable(name <- 'sav')
		
	do{				
		thisModule.PutAttributeTypeToBinaryOperator(attr, inpVarType);
	}
}

lazy rule Attribute2Initialization{
	from attr: Synthesis!AttributeDef(not attr.type.oclIsKindOf(Synthesis!Predicative))
	using{
		varName: String = 'a' + attr.name.amnId; 
	}
	to 	anySubst: AMN!Any(
			any <- varName,
			where <- predicate,
			thenPart <- beSubst			
		),
		predicate: AMN!AtomicPredicate (
			sign <- ':',
			expression <- var,
			expression <- varType
		),
		var: AMN!Variable(name <- varName),
		varType: AMN!BinaryOperator(
			sign <- '-->',
			expression <- ext			
		),
		ext: AMN!NamedConstant(name <- 'ext_' + attr.attributeOf.name.amnId),
		beSubst: AMN!BecomesEqual(
			leftExpression <- attrVar,
			rightExpression <- newAttrVar
		),
		attrVar: AMN!Variable(name <- attr.name.amnId),
		newAttrVar: AMN!Variable(name <- varName)
	do{
		thisModule.PutAttributeTypeToBinaryOperator(attr, varType);
		
		if(not attr.initialValue.oclIsUndefined())
			 anySubst.where <- thisModule.Attribute2InitialValuePredicate(attr);
	}
}


lazy rule Attribute2InitialValuePredicate{
	from attr: Synthesis!AttributeDef(
		(not attr.type.oclIsKindOf(Synthesis!Predicative)) and
		(not attr.initialValue.oclIsUndefined())
	)
	to 
		univ: AMN!UniversalPredicate(
			variable <- 'av',
			predicate <- impl
		),
		impl: AMN!Implication(
			predicate <- Sequence{varTyp, initPred} 
		),
		varTyp: AMN!AtomicPredicate (
			sign <- ':',
			expression <- var1,
			expression <- ext
		), 
		var1: AMN!Variable(name <- 'av'),
		ext: AMN!NamedConstant(name <- 'ext_' + attr.attributeOf.name.amnId),
		initPred: AMN!AtomicPredicate (
			sign <- '=',
			expression <- Sequence{attrFunc, thisModule.LazyValue(attr.initialValue)}
		), 
		attrFunc: AMN!FunctionalExpression(
			sign <- 'a' + attr.name.amnId,
			expression <- var2
		),
		var2: AMN!Variable(name <- 'av')		
}

lazy rule Attribute2CardinalityPredicate{
	from attr: Synthesis!AttributeDef(attr.hasCardinality)
	to 
		univ: AMN!UniversalPredicate(
			variable <- 'av',
			predicate <- impl
		),
		impl: AMN!Implication(
			predicate <- Sequence{varTyp, initPred} 
		),
		varTyp: AMN!AtomicPredicate (
			sign <- ':',
			expression <- var1,
			expression <- ext
		), 
		var1: AMN!Variable(name <- 'av'),
		ext: AMN!NamedConstant(name <- 'ext_' + attr.attributeOf.name.amnId),
		initPred: AMN!AtomicPredicate (
			sign <- '<=',
			expression <- cardFunc, 
			expression <- card
		), 
		cardFunc: AMN!FunctionalExpression(
			sign <- 'card',
			expression <- attrFunc
		),		
		attrFunc: AMN!FunctionalExpression(
			sign <- attr.name.amnId,
			expression <- var2
		),
		var2: AMN!Variable(name <- 'av'),
		card: AMN!IntegerValue(value <- attr.cardinality)
}

lazy rule Attribute2InversePredicate{
	from attr: Synthesis!AttributeDef(
		(not attr.type.oclIsKindOf(Synthesis!Predicative)) and
		(not attr.inverseAttribute.oclIsUndefined())
	)
	using{
		isSubtype: Boolean = false;
	}
	to 
		varTyp: AMN!AtomicPredicate (
			sign <- '=',
			expression <- thisModule.Attribute2SetComprehension(attr),
			expression <- invOp
		), 
		invOp: AMN!UnaryOperator(
			sign <- '~',
			expression <- thisModule.Attribute2SetComprehension(attr.inverseAttribute)
		)
	do{
		-- Put machine of inverse attribute type to machines of attribute type.
		isSubtype <- attr.attributeOf.isSubtypeOf(attr.inverseAttribute.attributeOf);
		let s: Boolean = isSubtype in s; -- To avoid stack overflow
						
		if(not isSubtype){		
			thisModule.resolveTemp(attr.attributeOf, 'am').includes <- thisModule.resolveTemp(attr.inverseAttribute.attributeOf, 'am');
			thisModule.resolveTemp(attr.attributeOf, 'ref').includes <- thisModule.resolveTemp(attr.inverseAttribute.attributeOf, 'am');
		}
	}
}

lazy rule Attribute2SetComprehension{
	from attr: Synthesis!AttributeDef(
		(not attr.type.oclIsKindOf(Synthesis!Predicative)) and 
		(attr.type.oclIsKindOf(Synthesis!ADTDef) or 
			(if attr.type.oclIsKindOf(Synthesis!SetDef) 
			 then 
			 	attr.type.ofType.oclIsKindOf(Synthesis!ADTDef)
			 else false
			 endif) )
	)
	using{
		domType: Synthesis!ADTDef = attr.attributeOf;
		ranType: Synthesis!ADTDef =
			if attr.type.oclIsKindOf(Synthesis!ADTDef)
			then attr.type
			else attr.type.ofType
			endif;
	}
	to 
		setCompr: AMN!SetComprehension(
			variable <- 'pair',
			predicate <- conj
		),
		conj: AMN!Conjunction(
			predicate <- pairTyping,
			predicate <- ex
		),
		
		pairTyping: AMN!AtomicPredicate(
			sign <- ':',
			expression <- pairVar1,
			expression <- pairType
		),
		pairVar1: AMN!Variable(name <- 'pair'),
		pairType: AMN!BinaryOperator(
			sign <- '*',
			expression <- thisModule.ADT_Typing(domType),
			expression <- thisModule.ADT_Typing(ranType)
		),
		
		ex: AMN!ExistentialPredicate(
			variable <- Sequence{'dd', 'rr'},
			predicate <- exConj
		),
		exConj: AMN!Conjunction(
			predicate <- domTyping,
			predicate <- ranTyping,
			predicate <- pairEq,
			predicate <- belongs
		),		
		domTyping: AMN!AtomicPredicate(
			sign <- ':',
			expression <- domVar1,
			expression <- thisModule.ADT_Typing(domType)
		),
		domVar1: AMN!Variable(name <- 'dd'),		
		ranTyping: AMN!AtomicPredicate(
			sign <- ':',
			expression <- ranVar1,
			expression <- thisModule.ADT_Typing(ranType)
		),
		ranVar1: AMN!Variable(name <- 'rr'),
		pairEq: AMN!AtomicPredicate(
			sign <- '=',
			expression <- pair,
			expression <- pairVar2
		),
		pair: AMN!BinaryOperator(
			sign <- '|->',
			expression <- domVar2,
			expression <- ranVar2
		),
		domVar2: AMN!Variable(name <- 'dd'),
		ranVar2: AMN!Variable(name <- 'rr'),
		pairVar2: AMN!Variable(name <- 'pair'),
		belongs: AMN!AtomicPredicate(
			sign <- if attr.type.oclIsKindOf(Synthesis!ADTDef) then '=' else ':' endif,
			expression <- ranVar3,
			expression <- attrFunc
		),
		ranVar3: AMN!Variable(name <- 'rr'),
		attrFunc: AMN!FunctionalExpression(
			sign <- attr.name.amnId,
			expression <- domVar3 
		),
		domVar3: AMN!Variable(name <- 'dd')		
}


rule PutAttributeCategoryToCompoundPredicate(
	attr: Synthesis!AttributeDef, 
	cat: Synthesis!AssociationMetaclassDef, 
	cp: AMN!CompoundPredicate
	)
{
	to
		catPred: AMN!AtomicPredicate(
			sign <- ':',
			expression <- thisModule.Attribute2SetComprehension(attr),
			expression <- clsVar
			
		),
		clsVar: AMN!Variable(name <- cat.name.amnId)
	do{
		cp.predicate <- catPred;
	}	
}


---------------------------------------
-- Association Metaclass transformation
---------------------------------------
rule AssociationMetaclass{
	from cls: Synthesis!AssociationMetaclassDef
	using{
		varName: String = cls.name.amnId;
		
		
		attr: Synthesis!AttributeDef = Synthesis!AttributeDef.allInstances()->any(a | a.classes->includes(cls));
		type: Synthesis!ADTDef = 
			if not attr.oclIsUndefined() 
			then attr.attributeOf
			else cls.instanceType
			endif;			
		am: AMN!AbstractMachine = 
			if not attr.oclIsUndefined() 
			then thisModule.resolveTemp(attr.attributeOf, 'am')
			else thisModule.resolveTemp(cls.instanceType, 'am')
			endif;
		ref: AMN!Refinement = 
			if not attr.oclIsUndefined() 
			then thisModule.resolveTemp(attr.attributeOf, 'ref')
			else thisModule.resolveTemp(cls.instanceType, 'ref')
			endif;

		ctxt: AMN!AbstractMachine = thisModule.resolveTemp(cls.classInModule, 'ctxt');
	}
	to 
		invAM: AMN!Conjunction(
			predicate <- thisModule.AssociationMetaclassVarTyping(cls),
			predicate <- thisModule.AssociationMetaclassVarEquality(cls)
		),
		invRef: AMN!Conjunction(
			predicate <- thisModule.AssociationMetaclassVarTyping(cls),
			predicate <- thisModule.AssociationMetaclassVarEquality(cls)
		)		
	do{
		-- Create metaclass variable.
		am.abstractVariables <- varName;
		ref.abstractVariables <- varName;

		-- Put context machine in SEES clause of metaclass machine.
		am.sees <- ctxt;
		ref.sees <- ctxt;
			
		for(sup in cls.superclasses){
			-- Put superclass machines into INCLUDES clause of metaclass machine.
			thisModule.PutMachineToIncludesClause(type, sup.instanceType);
		}
		
		-- Put domain machines into INCLUDES clause of metaclass machine.
		for(d in cls.domain){
			thisModule.PutMachineToIncludesClause(type, d.instanceType);
		}
		
		-- Put range machines into INCLUDES clause of metaclass machine.
		for(r in cls.range){
			thisModule.PutMachineToIncludesClause(type, r.instanceType);
		}
		
		-- Put initialization into metaclass machine
		am.initialization <- thisModule.AssociationMetaclassVarInit(cls);
		ref.initialization <- thisModule.AssociationMetaclassVarInit(cls);
		
		-- Put invariant into metaclass machine
		am.invariant <- invAM;
		ref.invariant <- invRef;
	}		
}

rule PutMachineToIncludesClause(type: Synthesis!ADTDef, referencedType: Synthesis!ADTDef){
	using{
		am: AMN!AbstractMachine = thisModule.resolveTemp(type, 'am');
		ref: AMN!Refinement = thisModule.resolveTemp(type, 'ref');
		includedMach: AMN!AbstractMachine = thisModule.resolveTemp(referencedType, 'am');
	
		isSubtype: Boolean = false;
	}
	do{
		
		isSubtype <- type.isSubtypeOf(referencedType);
		let s: Boolean = isSubtype in s; -- To avoid stack overflow		
		
		if(	(not am.extendsClause->includes(includedMach)) and (not isSubtype) ){
			am.includes <- includedMach;
			ref.includes <- includedMach;			
		}			
	}
}

-- cls: POW(dom1 \/ dom2 <-> ran1 \/ ran2)
lazy rule AssociationMetaclassVarTyping{
	from cls: Synthesis!AssociationMetaclassDef
	to 		
		clsVarTyping: AMN!AtomicPredicate(
			sign <- ':',
			expression <- clsVar,
			expression <- clsVarType
		),
		clsVar: AMN!Variable(name <- cls.name.amnId),
		clsVarType: AMN!FunctionalExpression(
			sign <- 'POW',
			expression <- thisModule.AssociationMetaclass2VarType(cls)
		)	
	do{
		''.debug('AM Var Typing: ' + cls.name.amnId);
	}
}

-- cls:= {}
lazy rule AssociationMetaclassVarInit{
	from cls: Synthesis!AssociationMetaclassDef
	to		
		initAM: AMN!BecomesEqual(
			leftExpression <- varInitAM,
			rightExpression <- emrtySetAM
		),
		varInitAM: AMN!Variable(name <- cls.name.amnId),
		emrtySetAM: AMN!SetValue	
}

-- cls = { av | av:  (dom1 \/ dom2 <-> ran1 \/ ran2) & av: sup &  
--				!dd.(dd: human => (card({rr| rr:human & (dd|->rr):this}) >= n1) & (card({rr| rr:human & (dd|->rr):this}) <= m1)) 
--				!rr.(rr: human => (card({dd| dd:human & (dd|->rr):this}) >= n2) & (card({dd| dd:human & (dd|->rr):this}) <= m2)) 		
--		 }
lazy rule AssociationMetaclassVarEquality{
	from cls: Synthesis!AssociationMetaclassDef
	to
		clsVarEq: AMN!AtomicPredicate(
			sign <- '=',
			expression <- clsVar,
			expression <- setCompr
		),
		clsVar: AMN!Variable(name <- cls.name.amnId),
		setCompr: AMN!SetComprehension(
			variable <- 'av',
			predicate <- setComprPred
		),
		setComprPred: AMN!Conjunction(
			predicate <- boundVarTyping,
			predicate <- cls.instanceType.attributes->select(attr | attr.type.oclIsKindOf(Synthesis!Predicative))->
				collect(attr | thisModule.LazyFormula(attr.type.predicativeSpec))
		),
		boundVarTyping: AMN!AtomicPredicate(
			sign <- ':',
			expression <- boundVar,
			expression <- thisModule.AssociationMetaclass2VarType(cls)
		),
		boundVar: AMN!Variable(name <- 'av')
	do{
		
		for(sup in cls.superclasses){
			-- Put superclass typing into set comprehension.
			setComprPred.predicate <- thisModule.Class2DefaultVarTyping(sup);
		}		
		
		-- Put cardinality restriction into invariant 
		thisModule.PutAssocMetaclassCardRestrictionToCompoundPredicate(cls, setComprPred, true);
		thisModule.PutAssocMetaclassCardRestrictionToCompoundPredicate(cls, setComprPred, false);		
	}
}

lazy rule Class2NamedConstant{
	from cls: Synthesis!ClassDef
	to nc: AMN!NamedConstant(name <- cls.name.amnId)
}

-- av: cls
lazy rule Class2DefaultVarTyping{
	from cls: Synthesis!ClassDef
	to 
		defVarTyping: AMN!AtomicPredicate(
			sign <- ':',
			expression <- defVar,
			expression <- clsConst
		),
		defVar: AMN!Variable(name <- 'av'),
		clsConst: AMN!NamedConstant(name <- cls.name.amnId)
}

-- (dom <-> ran)
-- (dom <-> ran1 \/ ran2)
-- (dom1 \/ dom2 <-> ran)
-- (dom1 \/ dom2 <-> ran1 \/ ran2)
lazy rule AssociationMetaclass2VarType{
	from cls: Synthesis!AssociationMetaclass (cls.domain->size() > 0 and cls.range.size() > 0)
	to 		
		domRanProd: AMN!BinaryOperator(
			sign <- '<->',
			expression <- if cls.domain->size() >= 2 then dom else thisModule.Class2NamedConstant(cls.domain->any(d | true)) endif,
			expression <- if cls.range->size() >= 2 then ran else thisModule.Class2NamedConstant(cls.range->any(d | true)) endif
		),		
		-- For the case of multiple classes in domain
		dom: AMN!BinaryOperator(
			sign <- '\\/',
			expression <- cls.domain->collect(d | thisModule.Class2NamedConstant(d))
		),
		-- For the case of multiple classes in range		
		ran: AMN!BinaryOperator(
			sign <- '\\/',
			expression <- cls.range->collect(r | thisModule.Class2NamedConstant(r))
		)
	do{
		''.debug('AM Var Type: ' + cls.name.amnId);
		if(cls.domain->size() = 1){ 
			''.debug('Single domain class name: ' +  thisModule.Class2NamedConstant(cls.domain->any(d | true)).name); 
		}		
	}
}

-- var: cls1 \/ cls2
rule PutUnionClassVarTypingToCompoundPredicate(formula: AMN!CompoundPredicate, varName: String, classes: Set(Synthesis!ClassDef)){
	to 
		typing: AMN!AtomicPredicate(
			sign <- ':',
			expression <- var,
			expression <- type 
		),
		var: AMN!Variable(name <- varName),
		type: AMN!BinaryOperator(
			sign <- '\\/',
			expression <- classes->collect(r | thisModule.Class2NamedConstant(r))
		)		
	do{
		formula.predicate <- typing;	
	}
}

-- card({ var | var: cls1 \/ cls2 & (dd |-> rr) : av }) >= n
--														<= m
rule PutAssocMetaclassCardPredicateToCompoundPredicate(
		formula: AMN!CompoundPredicate, 
		card: Integer, 
		domVarName: String,
		ranVarName: String,  
		classes: Set(Synthesis!ClassDef),
		domIsSetBound: Boolean,
		minCard: Boolean
	)
{
	to 
		cardPred: AMN!AtomicPredicate(
			sign <- if minCard then '>=' else '<='	endif,
			expression <- cardFunc,
			expression <- cardVal
		),
		cardVal: AMN!IntegerValue(value <- card),
		cardFunc: AMN!FunctionalExpression(
			sign <- 'card',
			expression <- setCompr
		),
		setCompr: AMN!SetComprehension(
			variable <- if domIsSetBound then domVarName else ranVarName endif,
			predicate <- setComprPred
		),
		setComprPred: AMN!Conjunction,
		pairTyping: AMN!AtomicPredicate(
			sign <- ':',
			expression <- pair,
			expression <- defaultVar
		),
		defaultVar: AMN!Variable(name <- 'av'),	
		pair: AMN!BinaryOperator(
			sign <- '|->',
			expression <- domVar,
			expression <- ranVar
		),
		domVar: AMN!Variable(name <- domVarName),
		ranVar: AMN!Variable(name <- ranVarName)
	do{
		formula.predicate <- cardPred;	
		thisModule.PutUnionClassVarTypingToCompoundPredicate(setComprPred, if domIsSetBound then domVarName else ranVarName endif, classes);
		setComprPred.predicate <- pairTyping;
	}
}

--!dd.(dd: human => (card({rr| rr:human & (dd|->rr):this}) >= n1) & (card({rr| rr:human & (dd|->rr):this}) <= m1)) 
--!rr.(rr: human => (card({dd| dd:human & (dd|->rr):this}) >= n2) & (card({dd| dd:human & (dd|->rr):this}) <= m2)) 
rule PutAssocMetaclassCardRestrictionToCompoundPredicate(
		cls: Synthesis!AssociationMetaclass,
		formula: AMN!CompoundPredicate, 
		domIsSetBound: Boolean
	)
{
	using{
		domVarName: String = 'dd';
		ranVarName: String = 'rr';
	}	
	to 
		cardRestr: AMN!UniversalPredicate(
			variable <- if domIsSetBound then ranVarName else domVarName endif,
			predicate <- implic
		),
		implic: AMN!Implication,
		conj: AMN!Conjunction
	do{
		formula.predicate <- cardRestr;
		
		if(domIsSetBound){
			thisModule.PutUnionClassVarTypingToCompoundPredicate(implic, ranVarName, cls.range);
			
			thisModule.PutAssocMetaclassCardPredicateToCompoundPredicate(conj, cls.minCard, domVarName, ranVarName, cls.domain, true, true);
			
			if(cls.maxCard > 0)
				thisModule.PutAssocMetaclassCardPredicateToCompoundPredicate(conj, cls.maxCard, domVarName, ranVarName, cls.domain, true, false);			
		}
		else{
			thisModule.PutUnionClassVarTypingToCompoundPredicate(implic, domVarName, cls.domain);
			
			thisModule.PutAssocMetaclassCardPredicateToCompoundPredicate(conj, cls.minInverseCard, domVarName, ranVarName, cls.range, false, true);
			
			if(cls.maxInverseCard > 0)
				thisModule.PutAssocMetaclassCardPredicateToCompoundPredicate(conj, cls.maxInverseCard, domVarName, ranVarName, cls.range, false, false);						
		}
				
		implic.predicate <- conj;
	}
}
	
--------------------------
-- Formulae transformation
--------------------------

lazy rule LazyFormula{
	from fSyn: Synthesis!Formula
	to fAMN: AMN!Predicate
}

-- Bracket
rule BracketFormula{
	from fSyn: Synthesis!BracketFormula
	to
		fAMN: AMN!Bracketed(
			predicate <- fSyn.formula
		)
}

lazy rule LazyBracketFormula extends LazyFormula{
	from fSyn: Synthesis!BracketFormula
	to
		fAMN: AMN!Bracketed(
			predicate <- fSyn.formula->collect(f | thisModule.LazyFormula(f))
		)
}

-- Conjunction
rule Conjunction {
	from fSyn: Synthesis!Conjunction
	to
		fAMN: AMN!Conjunction(
			predicate <- fSyn.formula
		)
}

lazy rule LazyConjunction extends LazyFormula{
	from fSyn: Synthesis!Conjunction
	to
		fAMN: AMN!Conjunction(
			predicate <- fSyn.formula->collect(f | thisModule.LazyFormula(f))
		)
}

-- Disjuction
rule Disjunction{
	from fSyn: Synthesis!Disjunction
	to
		fAMN: AMN!Disjunction (
			predicate <- fSyn.formula
		)
}

lazy rule LazyDisjunction extends LazyFormula{
	from fSyn: Synthesis!Disjunction
	to
		fAMN: AMN!Disjunction(
			predicate <- fSyn.formula->collect(f | thisModule.LazyFormula(f))
		)
}

-- Negation
rule Negation{
	from fSyn: Synthesis!Negation
	to
		fAMN: AMN!Negation(
			predicate <- fSyn.formula
		)
}

lazy rule LazyNegation extends LazyFormula{
	from fSyn: Synthesis!Negation
	to
		fAMN: AMN!Negation(
			predicate <- fSyn.formula->collect(f | thisModule.LazyFormula(f))
		)
}

-- Implication
rule Implication{
	from fSyn: Synthesis!Implication
	to
		fAMN: AMN!Implication(
			predicate <- fSyn.formula
		)
}

lazy rule LazyImplication extends LazyFormula{
	from fSyn: Synthesis!Implication
	to
		fAMN: AMN!Implication(
			predicate <- fSyn.formula->collect(f | thisModule.LazyFormula(f))
		)
}

-- Equivalence
rule Equivalence{
	from fSyn: Synthesis!Equivalence
	to
		fAMN: AMN!Equivalence(
			predicate <- fSyn.formula
		)
}

lazy rule LazyEquivalence extends LazyFormula{
	from fSyn: Synthesis!Equivalence
	to
		fAMN: AMN!Equivalence(
			predicate <- fSyn.formula->collect(f | thisModule.LazyFormula(f))
		)
}

-- Quantified
rule UniversallyQuantified{
	from 
		fSyn: Synthesis!UniversallyQuantifiedFormula
	to
		fAMN: AMN!UniversalPredicate(
			predicate <- body, 
			variable <- fSyn.variables->collect(v | v.name.amnId)
		),
		body: AMN!Implication(
			predicate <- varTyping,
			predicate <- fSyn.formula
		),
		varTyping: AMN!Conjunction(
			predicate <- fSyn.variables->collect(v | thisModule.TypedVar2Predicate(v))
		)
}

lazy rule LazyUniversal extends LazyFormula{
	from fSyn: Synthesis!UniversallyQuantifiedFormula
	to
		fAMN: AMN!UniversalPredicate(
			predicate <- body, 
			variable <- fSyn.variables->collect(v | v.name.amnId)
		),
		body: AMN!Implication(
			predicate <- varTyping,
			predicate <- fSyn.formula->collect(f | thisModule.LazyFormula(f))
		),
		varTyping: AMN!Conjunction(
			predicate <- fSyn.variables->collect(v | thisModule.TypedVar2Predicate(v))
		)
}

rule ExistentiallyQuantified{
	from 
		fSyn: Synthesis!ExistentiallyQuantifiedFormula
	to
		fAMN: AMN!ExistentialPredicate(
			predicate <- body, 
			variable <- fSyn.variables->collect(v | v.name.amnId)
		),
		body: AMN!Conjunction (
			predicate <- fSyn.variables->collect(v | thisModule.TypedVar2Predicate(v)),
			predicate <- fSyn.formula
		)
		
}

lazy rule LazyExistential extends LazyFormula{
	from fSyn: Synthesis!ExistentiallyQuantifiedFormula
	to
		fAMN: AMN!ExistentialPredicate(
			predicate <- body, 
			variable <- fSyn.variables->collect(v | v.name.amnId)
		),
		body: AMN!Conjunction(
			predicate <- fSyn.variables->collect(v | thisModule.TypedVar2Predicate(v)),
			predicate <- fSyn.formula->collect(f | thisModule.LazyFormula(f))
		)
}

lazy rule TypedVar2Predicate{
	from var: Synthesis!Variable
	to
		p: AMN!AtomicPredicate (
			sign <- ':',
			expression <- left
		),
		left: AMN!Variable(name <- var.name.amnId)
	do {
		thisModule.PutTypeToAtomicPredicate(var.type, p);	
	}		
}

-- Builtin predicate
rule BuiltinPredicate{
	from 
		fSyn: Synthesis!Atom(fSyn.oclIsTypeOf(Synthesis!Atom) and fSyn.isBuiltin)
	to
		fAMN: AMN!AtomicPredicate(
			expression <- 
				-- is_in predicate posesses reverse order of params
				if fSyn.symbol = 'is_in' 
				then Sequence{fSyn.terms->asSequence()->at(2), fSyn.terms->asSequence()->at(1)}
				else fSyn.terms
				endif
		)
	do{
		if(fSyn.symbol = 'is_in') fAMN.sign <- ':';
		if(fSyn.symbol = 'same') fAMN.sign <- '=';
		if(fSyn.symbol = 'is_empty'){
			fAMN.sign <- '=';
			thisModule.PutEmptySetToAtomic(fAMN);
		}
	}
}

lazy rule LazyBuiltinPredicate extends LazyFormula{
	from 
		fSyn: Synthesis!Atom(fSyn.oclIsTypeOf(Synthesis!Atom) and fSyn.isBuiltin)
	to
		fAMN: AMN!AtomicPredicate(
			expression <- 
				-- is_in predicate posesses reverse order of params
				if fSyn.symbol = 'is_in' 
				then Sequence{thisModule.LazyValue(fSyn.terms->asSequence()->at(2)), 
						thisModule.LazyValue(fSyn.terms->asSequence()->at(1))}
				else fSyn.terms->collect(v | thisModule.LazyValue(v))
				endif
		)
	do{
		if(fSyn.symbol = 'is_in') fAMN.sign <- ':';
		if(fSyn.symbol = 'same') fAMN.sign <- '=';
		if(fSyn.symbol = 'is_empty'){
			fAMN.sign <- '=';
			thisModule.PutEmptySetToAtomic(fAMN);
		}
	}
}


rule PutEmptySetToAtomic(atom: AMN!AtomicPredicate){
	to val: AMN!SetValue
	do{
		atom.expression <- val;
	}
}

-- Atom
rule Atom{
	from 
		fSyn: Synthesis!Atom(
			fSyn.oclIsTypeOf(Synthesis!Atom) and 
			(not fSyn.isBuiltin) and
			fSyn.isCollectionPredicate
		)
	using{
		pred: Synthesis!Predicative = OclUndefined;		
		cls: Synthesis!ClassDef = Synthesis!ClassDef.allInstances()->
			select(e | e.name.amnId = fSyn.symbol.amnId)->any(e | e.oclIsKindOf(Synthesis!ClassDef));	
		isSubtype: Boolean = false;
	}
	to
		fAMN: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{fSyn.terms, var}
		),
		var: AMN!Variable(name <- fSyn.symbol)
	do{
		-- Atom is a part of specification of some predicative.
		pred <- fSyn.specifies;
		if(not pred.oclIsUndefined()){			
			-- Add class instance type machine to SEES or INCLUDES clause of ref
			-- which entity is described by variable.
			if(not cls.oclIsUndefined()){
				for(a in pred.typeOfAttribute){					 					
					-- Attribute is a method of type, not a lonely function
					if(not a.attributeOf.oclIsUndefined()){
						isSubtype <- a.attributeOf.isSubtypeOf(cls.instanceType);
						let s: Boolean = isSubtype in s; -- To avoid stack overflow
						
						if(not isSubtype){
							-- Class occures in invariant - have to be added to INCLUDES
							if(pred.oclIsKindOf(Synthesis!InvariantDef)){
								thisModule.resolveTemp(a.attributeOf, 'ref').includes <- thisModule.resolveTemp(cls.instanceType, 'am');
								thisModule.resolveTemp(a.attributeOf, 'am').includes <- thisModule.resolveTemp(cls.instanceType, 'am');
							}
							
							-- Class occures in method - have to be added to SEES
							if(pred.oclIsKindOf(Synthesis!FunctionDef))
							if(not thisModule.resolveTemp(a.attributeOf, 'ref').includes->includes(thisModule.resolveTemp(cls.instanceType, 'am')))
								thisModule.resolveTemp(a.attributeOf, 'ref').sees <- thisModule.resolveTemp(cls.instanceType, 'am');
						}
					}
				}
			}
			
		}				
	}
}

lazy rule LazyAtom extends LazyFormula{
	from 
		fSyn: Synthesis!Atom(
			fSyn.oclIsTypeOf(Synthesis!Atom) and 
			(not fSyn.isBuiltin) and
			fSyn.isCollectionPredicate
		)
	to
		fAMN: AMN!AtomicPredicate(
			sign <- ':',			
			expression <- fSyn.terms->collect(t | thisModule.LazyValue(t)),
			expression <- var
		),
		var: AMN!Variable(name <- fSyn.symbol)
}

rule RelationPredicate{
	from 
		fSyn: Synthesis!RelationPredicate
	to
		fAMN: AMN!AtomicPredicate(
			expression <- fSyn.terms
		)		
	do{
		-- Set predicates
		if(fSyn.symbol = '<') fAMN.sign <- '<<:';
		if(fSyn.symbol = '<=') fAMN.sign <- '<:';
		
		-- Arithmetic predicates
		if(fSyn.symbol = 'lt') fAMN.sign <- '<';
		if(fSyn.symbol = 'le') fAMN.sign <- '<=';		
		if(fSyn.symbol = '>=' or fSyn.symbol = 'ge') fAMN.sign <- '>=';
		if(fSyn.symbol = '>' or fSyn.symbol = 'gt') fAMN.sign <- '>';
		if(fSyn.symbol = '<>' or fSyn.symbol = 'ne') fAMN.sign <- '/=';
		if(fSyn.symbol = '=' or fSyn.symbol = 'eq') fAMN.sign <- '=';		
	}
}

lazy rule LazyRelationPredicate extends LazyFormula{
	from 
		fSyn: Synthesis!RelationPredicate
	to
		fAMN: AMN!AtomicPredicate(
			expression <- fSyn.terms->collect(t | thisModule.LazyValue(t))
		)		
	do{
		-- Set predicates
		if(fSyn.symbol = '<') fAMN.sign <- '<<:';
		if(fSyn.symbol = '<=') fAMN.sign <- '<:';
		
		-- Arithmetic predicates
		if(fSyn.symbol = 'lt') fAMN.sign <- '<';
		if(fSyn.symbol = 'le') fAMN.sign <- '<=';		
		if(fSyn.symbol = '>=' or fSyn.symbol = 'ge') fAMN.sign <- '>=';
		if(fSyn.symbol = '>' or fSyn.symbol = 'gt') fAMN.sign <- '>';
		if(fSyn.symbol = '<>' or fSyn.symbol = 'ne') fAMN.sign <- '/=';
		if(fSyn.symbol = '=' or fSyn.symbol = 'eq') fAMN.sign <- '=';		
	}
}

-----------------------
-- Term transformation
-----------------------
lazy rule LazyValue{
	from valSyn: Synthesis!ValueDef
	to valAMN: AMN!Expression
}

-- Variable
rule Variable{
	from valSyn: Synthesis!Variable
	using{
		-- Variable to overcome 'org.eclipse.m2m.atl.engine.emfvm.VMException: 100' error		
		--stackConsume: String = ''; 

		varName: String = valSyn.name.amnId;
		
		pred: Synthesis!Predicative = OclUndefined;		
		varType: Synthesis!TypeDef = OclUndefined;
		
		cls: Synthesis!ClassDef = Synthesis!ClassDef.allInstances()->
			select(e | e.name.amnId = varName)->any(e | e.oclIsKindOf(Synthesis!ClassDef));
		
		isSubtype: Boolean = false;
	}
	to 	valAMN: AMN!Variable(
			name <- varName
		)
	do{
		-- For a variable that is a part of specification of some predicative.
		pred <- valSyn.specifies;
		if(not pred.oclIsUndefined()){			
			-- Search its var name in output params of the predicative. 
			-- If variable is an output param then transform its name with tempVarName.
			if(pred.parameters->select(p | p.parameterKind = '-')->collect(p | p.name.amnId)->includes(varName))
				valAMN.name <- valSyn.tempVarName;	
			
			-- If variable is 'this', use conventional name for first param of object method
			if(varName = 'this')
				valAMN.name <- thisModule.firstParamOfObjectMethod;
				
			-- If variable is a class name.
			-- Add class instance type machine to SEES or INCLUDES clause of machine
			-- which entity is described by variable.
			if(not cls.oclIsUndefined()){
				for(a in pred.typeOfAttribute){
					-- Attribute is  method of type, not a lonely function
					if(not a.attributeOf.oclIsUndefined()){
						isSubtype <- a.attributeOf.isSubtypeOf(cls.instanceType);
						let s: Boolean = isSubtype in s; -- To avoid stack overflow
						
						if(not isSubtype){
							-- Class occures in invariant - have to be added to INCLUDES
							if(pred.oclIsKindOf(Synthesis!InvariantDef)){
								thisModule.resolveTemp(a.attributeOf, 'ref').includes <- thisModule.resolveTemp(cls.instanceType, 'am');
								thisModule.resolveTemp(a.attributeOf, 'am').includes <- thisModule.resolveTemp(cls.instanceType, 'am');
							}
							
							-- Class occures in method - have to be added to SEES
							if(pred.oclIsKindOf(Synthesis!FunctionDef))
							if(not thisModule.resolveTemp(a.attributeOf, 'ref').includes->includes(thisModule.resolveTemp(cls.instanceType, 'am')))
								thisModule.resolveTemp(a.attributeOf, 'ref').sees <- thisModule.resolveTemp(cls.instanceType, 'am');											
						}
					}
				}
			}			
		}	
		
		-- DEBUG
		--varType <- varSyn.variableType(varSyn);
		--stackConsume <- let s: String = 'Var ' + varName in s.println();
	}
}

lazy rule LazyVariable extends LazyValue{
	from valSyn: Synthesis!Variable
	using{
		varName: String = valSyn.name.amnId;
		
		pred: Synthesis!Predicative = OclUndefined;		
		varType: Synthesis!TypeDef = OclUndefined;
	}
	to 	valAMN: AMN!Variable(
			name <- varName
		)
	do{
		-- For a variable that is a part of specification of some predicative.
		pred <- valSyn.specifies;
		if(not pred.oclIsUndefined()){			
			-- Search its var name in output params of the predicative. 
			-- If variable is an output param then transform its name with tempVarName.
			if(pred.parameters->select(p | p.parameterKind = '-')->collect(p | p.name.amnId)->includes(varName))
				valAMN.name <- valSyn.tempVarName;	
			
			-- If variable is 'this', use conventional name for first param of object method
			if(varName = 'this')
				valAMN.name <- thisModule.firstParamOfObjectMethod;			
		}	
	}
}

-- Values
rule StringValue{
	from valSyn: Synthesis!StringValueDef
	to valAMN: AMN!StringValue(value <- valSyn.value)
}

lazy rule LazyStringValue extends LazyValue{
	from valSyn: Synthesis!StringValueDef
	to valAMN: AMN!StringValue(value <- valSyn.value)
}

rule BooleanValue{
	from valSyn: Synthesis!BooleanValueDef
	to valAMN: AMN!BooleanValue(value <- valSyn.value)
}

lazy rule LazyBooleanValue extends LazyValue{
	from valSyn: Synthesis!BooleanValueDef
	to valAMN: AMN!BooleanValue(value <- valSyn.value)
}

rule IntValue{
	from valSyn: Synthesis!IntValueDef
	to valAMN: AMN!IntegerValue(value <- valSyn.value)
}

lazy rule LazyIntValue extends LazyValue{
	from valSyn: Synthesis!IntValueDef
	to valAMN: AMN!IntegerValue(value <- valSyn.value)
}

rule SetValue{
	from valSyn: Synthesis!SetValueDef
	to valAMN: AMN!SetValue(value <- valSyn.contents)
}

lazy rule LazySetValue extends LazyValue{
	from valSyn: Synthesis!SetValueDef
	to valAMN: AMN!SetValue(value <- valSyn.contents->collect(e | thisModule.LazyValue(e)))
}

rule SequenceValue {
	from valSyn: Synthesis!SequenceValueDef
	to 	valAMN: AMN!BinaryOperator(
			sign <- '|->',
			expression <- valSyn.contents
		)
}

lazy rule LazySequenceValue extends LazyValue{
	from valSyn: Synthesis!SequenceValueDef
	to 	valAMN: AMN!BinaryOperator(
			sign <- '|->',
			expression <- valSyn.contents->collect(e | thisModule.LazyValue(e))
		)
}

rule CollectionComprehension{
	from valSyn: Synthesis!CollectionComprehension
	to
		valAMN: AMN!SetComprehension(
			variable <- valSyn.variables->collect(v | v.name.amnId),
			predicate <- conj
		),
		conj: AMN!Conjunction (
			predicate <- valSyn.variables->collect(v | thisModule.TypedVar2Predicate(v)),
			predicate <- valSyn.formula	
		)
}

lazy rule LazyCollectionComprehension extends LazyValue{
	from valSyn: Synthesis!CollectionComprehension
	to
		valAMN: AMN!SetComprehension(
			variable <- valSyn.variables->collect(v | v.name.amnId),
			predicate <- conj
		),
		conj: AMN!Conjunction (
			predicate <- valSyn.variables->collect(v | thisModule.TypedVar2Predicate(v)),
			predicate <- thisModule.LazyFormula(valSyn.formula)	
		)
}


rule BracketValue{
	from valSyn: Synthesis!BracketValue
	to valAMN: AMN!BracketedExpression(expression <- valSyn.terms->asSequence()->at(1))
}

lazy rule LazyBracketValue extends LazyValue{
	from valSyn: Synthesis!BracketValue
	to 
		valAMN: AMN!BracketedExpression(
			expression <- thisModule.LazyValue(valSyn.terms->asSequence()->at(1))
		)
}

-- Binary operator
rule BinaryOperator{
	from valSyn: Synthesis!FunctionCall(valSyn.isBinaryOperator)
	to 	valAMN: AMN!BinaryOperator(
			expression <- valSyn.terms
		)
	do{
		if(valSyn.name = '+' or valSyn.name = '-' or valSyn.name = '*') valAMN.sign <- valSyn.name;
		if(valSyn.name = '%') valAMN.sign <- '/';
		if(valSyn.name = 'uni') valAMN.sign <- '\\/';
		if(valSyn.name = 'intersect') valAMN.sign <- '/\\';
		if(valSyn.name = 'differ') valAMN.sign <- '-';		
	}
}

lazy rule LazyBinaryOperator extends LazyValue{
	from valSyn: Synthesis!FunctionCall(valSyn.isBinaryOperator)
	to 	valAMN: AMN!BinaryOperator(
			expression <- valSyn.terms->collect(t | thisModule.LazyValue(t))
		)
	do{
		if(valSyn.name = '+' or valSyn.name = '-' or valSyn.name = '*') valAMN.sign <- valSyn.name;
		if(valSyn.name = '%') valAMN.sign <- '/';
		if(valSyn.name = 'uni') valAMN.sign <- '\\/';
		if(valSyn.name = 'intersect') valAMN.sign <- '/\\';
		if(valSyn.name = 'differ') valAMN.sign <- '-';		
	}
}

-- Builtin function
rule BuiltinFunctionCall{
	from valSyn: Synthesis!FunctionCall(
			if valSyn.name.oclIsUndefined() 
			then false
			else
				if not valSyn.isBinaryOperator
				then true
				else false
				endif
			endif
		)
	to 	valAMN: AMN!FunctionalExpression(
			expression <- valSyn.terms
		)
	do{
		if(valSyn.name = 'cardinal') valAMN.sign <- 'card';
		else valAMN.sign <- valSyn.name.amnId;
	}
}

lazy rule LazyBuiltinFunctionCall extends LazyValue{
	from valSyn: Synthesis!FunctionCall(
			if valSyn.name.oclIsUndefined() 
			then false
			else
				if not valSyn.isBinaryOperator
				then true
				else false
				endif
			endif
		)
	to 	valAMN: AMN!FunctionalExpression(
			expression <- valSyn.terms->collect(t | thisModule.LazyValue(t))
		)
	do{
		if(valSyn.name = 'cardinal') valAMN.sign <- 'card';
		else valAMN.sign <- valSyn.name.amnId;
	}
}


-- Navigation path not referring to poststate
rule NavigationPath{
	from np: Synthesis!NavigationPath((not np.refersToPoststate) and np.isSimple)
	using{
		subSeq: Sequence(Synthesis!Variable) = np.terms->asSequence()->subSequence(1, np.terms->size()-1);
		tail: Sequence(Synthesis!Variable) = np.terms->asSequence()->subSequence(2, np.terms->size());
		head: Synthesis!Variable = subSeq->first();

		typeOf: Synthesis!TypeDef = OclUndefined;
		attrType: Synthesis!TypeDef = OclUndefined;

		pred: Synthesis!Predicative = OclUndefined;		

		isSubtype: Boolean = false;
	}
	to 	fe: AMN!FunctionalExpression(
			sign <- np.terms->asSequence()->last().name.amnId
		)
	do{
		--let s: String = 'PATH: ' + np.toString() in s.println(); -- DEBUG
		
		-- Create functional expression corresponding to path
		if(np.terms->size() > 2)
			thisModule.Variables2FunctionalExpression(subSeq, fe);
		else
			fe.expression <- thisModule.resolveTemp(head, 'valAMN');				
		
		-- Calc type of path's source
		--let s: String = 'Path source ' + head.name + ' ' in s.println(); -- DEBUG
		typeOf <- np.variableType(head);
		
		-- Add machines correspond to types of path elements to SEES or INCLUDES clause
		-- of entity specified by the path
		pred <- np.specifies;	
		--let s: String = typeOf.name in s.println(); -- DEBUG		
		for(v in tail){
			-- Add attrType machine to SEES OR INCLUDES clause of ref
			-- which entity is described by path.						
			if(not typeOf.oclIsUndefined())
			if(typeOf.oclIsKindOf(Synthesis!ADTDef)){				
				if(not pred.oclIsUndefined()){			
					for(a in pred.typeOfAttribute){
						-- Attribute is  method of type, not a lonely function
						if(not a.attributeOf.oclIsUndefined()){
							isSubtype <- a.attributeOf.isSubtypeOf(typeOf);
							let s: Boolean = isSubtype in s; -- To avoid stack overflow
															
							if(not isSubtype){									
								-- Attribute occures in invariant - have to be added to INCLUDES
								if(pred.oclIsKindOf(Synthesis!InvariantDef)){
									let s: String = a.attributeOf.name + ' includes ' + typeOf.name in s.println(); -- Debug
									thisModule.resolveTemp(a.attributeOf, 'ref').includes <- thisModule.resolveTemp(typeOf, 'am');
									thisModule.resolveTemp(a.attributeOf, 'am').includes <- thisModule.resolveTemp(typeOf, 'am');
								}
								
								-- Attribute occures in method - have to be added to SEES
								if(pred.oclIsKindOf(Synthesis!FunctionDef))
								if(not thisModule.resolveTemp(a.attributeOf, 'ref').includes->includes(thisModule.resolveTemp(typeOf, 'am'))){
									let s: String = a.attributeOf.name + ' sees ' + typeOf.name in s.println(); -- Debug
									thisModule.resolveTemp(a.attributeOf, 'ref').sees <- thisModule.resolveTemp(typeOf, 'am');
								}
							}
						}	
					}				
				}															
			}
			
			attrType <- typeOf.hasAttribute(v.name);
			if(not attrType.oclIsUndefined())
				let s: String = 'Path elem ' + v.name + ' ' + attrType.name in s.println(); -- DEBUG
				
			typeOf <- attrType;
		}		
	}
}

lazy rule LazyNavigationPath extends LazyValue{
	from valSyn: Synthesis!NavigationPath((not valSyn.refersToPoststate) and valSyn.isSimple)
	using{
		subSeq: Sequence(Synthesis!Variable) = valSyn.terms->asSequence()->subSequence(1, valSyn.terms->size()-1);
		head: Synthesis!Variable = subSeq->first();
	}
	to 	valAMN: AMN!FunctionalExpression(
			sign <- valSyn.terms->asSequence()->last().name.amnId
		)
	do{
		-- Create functional expression corresponding to path
		if(valSyn.terms->size() > 2)
			thisModule.Variables2FunctionalExpression(subSeq, valAMN);
		else
			valAMN.expression <- thisModule.LazyValue(head);						
	}
}


rule Variables2FunctionalExpression(terms: Sequence(Synthesis!VariableDef), exp: AMN!FunctionalExpression){
	using{
		size: Integer = terms->size();
	}
	to 	fe: AMN!FunctionalExpression(
			sign <- terms->last().name.amnId
		)
	do{
		exp.expression <- fe;
		
		''.debug('size: ' + size);
		if(size > 2)
			thisModule.Variables2FunctionalExpression(terms->subSequence(1, size-1), fe);
		else
			fe.expression <- thisModule.LazyValue(terms->first());
	}	
}

rule Effect{
	from np: Synthesis!NavigationPath(np.refersToPoststate and np.isSimple)
	using{
		subSeq: Sequence(Synthesis!Variable) = np.terms->asSequence()->subSequence(1, np.terms->size()-1);
		tail: Sequence(Synthesis!Variable) = 
			if np.terms->size() > 2 
			then np.terms->asSequence()->subSequence(2, np.terms->size() - 1)
			else Sequence{}
			endif;
		head: Synthesis!Variable = subSeq->first();

		typeOf: Synthesis!TypeDef = OclUndefined;
		attrType: Synthesis!TypeDef = OclUndefined;

		pred: Synthesis!Predicative = OclUndefined;		
		attr: Synthesis!AttributeDef = OclUndefined;
			
		isSubtype: Boolean = false;
		
		npStr: String = np.toString();
			
		effVarName: String = 'eff';
		effMap: Map(String, Integer) = Map{};
		effVarNumber: Integer = 0;
		multiplePathOccurence: Boolean = false;
	}
	to 				
		effVar: AMN!Variable,
		fe: AMN!FunctionalExpression(
			sign <- np.terms->asSequence()->last().name.amnId
		)
	do{
		
		let s: String = 'EFFECT: ' + np.toString() in s.println(); -- DEBUG
		let s: String = 'Specifies type: ' + np.specifiesType.toString() in s.println(); -- DEBUG
		
		-- Create functional expression corresponding to path
		if(np.terms->size() > 2)
			thisModule.Variables2FunctionalExpression(subSeq, fe);
		else
			fe.expression <- thisModule.resolveTemp(head, 'valAMN');				
		
		-- Predicate specified by path
		pred <- np.specifies;				
		
		-- Calc type of path's source
		typeOf <- np.variableType(head);		
		
		-- Add machines correspond to types of path elements to SEES or INCLUDES clause
		-- of entity specified by the path
		if(not typeOf.oclIsUndefined())
		if(not pred.oclIsUndefined())
		if(typeOf.oclIsKindOf(Synthesis!ADTDef)){			
			-- Add typeOf machine to SEES clause of ref
			-- which entity is described by path.		
			
			for(a in pred.typeOfAttribute){
				-- Attribute is  method of type, not a lonely function
				if(not a.attributeOf.oclIsUndefined()){
					isSubtype <- a.attributeOf.isSubtypeOf(typeOf);
					let s: Boolean = isSubtype in s; -- To avoid stack overflow
					
					if(not isSubtype){
						-- Attribute is modified - have to be added to INCLUDES
						if(np.terms->size() = 2){
							thisModule.resolveTemp(a.attributeOf, 'ref').includes <- thisModule.resolveTemp(typeOf, 'am');
						}
						
						-- Attribute is not modified - have to be added to SEES
						if(pred.oclIsKindOf(Synthesis!FunctionDef) and np.terms->size() > 2)
						if(not thisModule.resolveTemp(a.attributeOf, 'ref').includes->includes(thisModule.resolveTemp(typeOf, 'am')))	
							thisModule.resolveTemp(a.attributeOf, 'ref').sees <- thisModule.resolveTemp(typeOf, 'am');
					}
				}									
			}				
	
			--let s: String = typeOf.name in s.println();		
			for(v in tail){
				attrType <- typeOf.hasAttribute(v.name); 
				let s: String = 'Elm of path type: ' + attrType.toString() in s.println();
				
				-- Add attrType machine to SEES clause of ref
				-- which entity is described by path.						
				if(not attrType.oclIsUndefined())
				if(attrType.oclIsKindOf(Synthesis!ADTDef)){
					let s: String = 'Path elem ' + v.name + ' ' + attrType.name in s.println(); -- DEBUG		
					for(a in pred.typeOfAttribute){
						-- Attribute is  method of type, not a lonely function
						if(not a.attributeOf.oclIsUndefined()){
							isSubtype <- a.attributeOf.isSubtypeOf(attrType);
							let s: Boolean = isSubtype in s; -- To avoid stack overflow							
																						
							if(not isSubtype){
								-- Last path element machine have to be added to INCLUDES clause (modification of attribute)
								if(v = tail->last()){
									thisModule.resolveTemp(a.attributeOf, 'ref').includes <- thisModule.resolveTemp(attrType, 'am');
								}
								
								-- Non-last path element machine have to be added to SEES clause
								if(pred.oclIsKindOf(Synthesis!FunctionDef) and np.terms->size() > 2)
								if(not thisModule.resolveTemp(a.attributeOf, 'ref').includes->includes(thisModule.resolveTemp(attrType, 'am')))	
									thisModule.resolveTemp(a.attributeOf, 'ref').sees <- thisModule.resolveTemp(attrType, 'am');
							}
																
						}
					}																			
				}
				typeOf <- attrType;
			}
		}		
						
		attrType <- typeOf.hasAttribute(np.terms->last().name);
		let s: String = 'Last elm of path type: ' + attrType.toString() in s.println();

		-- Calculate number of temporary path variable
		--
		-- No paths for predicate is presented yet
		if(not(thisModule.pathVars.getKeys()->includes(pred))){
			thisModule.pathVars <- thisModule.pathVars.including(pred, Map{(npStr, 1)}); 
			effVarName <- effVarName + '1';
		}
		-- Paths for predicate are presented
		else{
			-- No occurence of np was processed yet
			if(not(thisModule.pathVars.get(pred).getKeys()->includes(npStr))){
				effMap <- thisModule.pathVars.get(pred); 
				effVarNumber <- effMap.getKeys()->size() + 1;
				thisModule.pathVars <- thisModule.pathVars.including(pred, effMap.including(npStr, effVarNumber));
				effVarName <- effVarName + effVarNumber;
			}
			-- Some occurences of np have already been processed
			else{
				multiplePathOccurence <- true;
				effMap <- thisModule.pathVars.get(pred); 
				effVarNumber <- effMap.get(npStr);
				thisModule.pathVars <- thisModule.pathVars.including(pred, effMap.including(npStr, effVarNumber));	
				effVarName <- effVarName + effVarNumber;
			}
		}
		
		-- Add staff in operation specified by path 
		if(not pred.oclIsUndefined())
		if(not pred.typeOfAttribute.oclIsUndefined()){
			attr <- pred.typeOfAttribute->any(a | a.oclIsKindOf(Synthesis!AttributeDef));
			
			effVar.name <- effVarName;			
			
			thisModule.resolveTemp(attr, 'anySubst').any <- effVarName;						
			
			-- If predicate contains several ocurences of the path,
			-- only one substitution and path var typing have to be added.
			if(not multiplePathOccurence){
				-- Typing of effect variable
				thisModule.PutVariableTypingToCompoundPredicate(effVarName, attrType, thisModule.resolveTemp(attr, 'whr'));
				
				-- Modified attribute belongs to the specified type - no need to call operation
				if(typeOf = np.specifiesType)				
					thisModule.PutBecomesEqualToSimultaneous(effVarName, fe, thisModule.resolveTemp(attr, 'simSubst'));
				-- Modified attribute belongs to some other type - operation call is required
				else{
					--let s: String = 'CALL ' + call.toString() in s.println; -- DEBUG										
					thisModule.PutCallToSimultaneous(
						'set_' + np.terms->asSequence()->last().name.amnId,
						effVarName,
						fe.expression->any(e | e.oclIsKindOf(AMN!Expression)),
						thisModule.resolveTemp(attr, 'simSubst')
					);
				}								
			}
		}										
	}
}

rule PutVariableTypingToCompoundPredicate(varName: String, type: Synthesis!TypeDef, pred: AMN!CompoundPredicate){
	to 	
		typing: AMN!AtomicPredicate (
			sign <- ':',
			expression <- var
		),
		var: AMN!Variable(name <- varName)	
	do{
		thisModule.PutTypeToAtomicPredicate(type, typing);
		pred.predicate <- typing;
	}
}

rule PutBecomesEqualToSimultaneous(varName: String, exp: AMN!Expression, sim: AMN!Simultaneous){
	to
		assign: AMN!BecomesEqual(
			leftExpression <- exp,
			rightExpression <- var
		),
		var: AMN!Variable(name <- varName)
	do{
		sim.substitution <- assign;
	}
	
}

rule PutCallToSimultaneous(opName: String, varName: String, exp: AMN!Expression, sim: AMN!Simultaneous){
	to
		call: AMN!Call(
			operationName <- operationId,
			actualParam <- setVal
		),
		operationId: AMN!CompoundId(id <- opName),
		setVal: AMN!SetValue(value <- bop),
		bop: AMN!BinaryOperator(
			sign <- '|->',
			expression <- Sequence{exp, var}
		),
		var: AMN!Variable(name <- varName)			
	do{
		sim.substitution <- call;
	}	
}

-------------------------
-- Method transformation
-------------------------
--
-- These rules are put later that NavigationPath in this file 
-- to let effect variable typing to be put in 'where' clause earlier
-- than method specification

rule FunctionalAttribute2Operation{	
	from
		attr: Synthesis!AttributeDef(attr.type.oclIsKindOf(Synthesis!FunctionDef))
	using{
		inputPars: Sequence(Synthesis!ParameterDef) = attr.type.parameters->select(p | p.parameterKind = '+');	
		outputPars: Sequence(Synthesis!ParameterDef) = attr.type.parameters->select(p | p.parameterKind = '-');	
	}
	to
		operation: AMN!Operation (
			name <- attr.name.amnId,
			inputParams <- thisModule.firstParamOfObjectMethod,
			inputParams <- inputPars->collect(p | p.name.amnId),
			outputParams <- outputPars->collect(p | p.name.amnId),
			substitution <- subst
		),
		subst: AMN!Precondition(
			pre <- objParamTyping,
			pre <- inputPars,
			thenPart <- anySubst 
		),
		
		-- First param typing
		objParamTyping: AMN!AtomicPredicate (
			sign <- ':',
			expression <- Sequence{objParam, ext} 
		),
		objParam: AMN!Variable(name <- thisModule.firstParamOfObjectMethod),		
		ext: AMN!NamedConstant(name <- 'ext_' + attr.attributeOf.name.amnId),
		
		-- Substitutions
		anySubst: AMN!Any(
			any <- outputPars->collect(p | p.outParamTempVarName),
			where <- whr,
			thenPart <- simSubst
		),
		whr: AMN!Conjunction(
			predicate <- outputPars,
			predicate <- attr.type.predicativeSpec
		),
		simSubst: AMN!Simultaneous(
			substitution <- outputPars->collect(p | thisModule.resolveTemp(p, 'assign'))
		),
		
		-- Operation with empty body for refined machine
		emptyBodyOperation: AMN!Operation (
			name <- attr.name.amnId,
			inputParams <- thisModule.firstParamOfObjectMethod,
			inputParams <- inputPars->collect(p | p.name.amnId),
			outputParams <- outputPars->collect(p | p.name.amnId),
			substitution <- subst1
		),
		subst1: AMN!Precondition(
			pre <- objParamTyping1,
			pre <- inputPars->collect(p | thisModule.resolveTemp(p, 'paramTyping1')),
			thenPart <- 				
				if outputPars.size() > 0 
				then anySubst1
				else skip
				endif 
		),		
		objParamTyping1: AMN!AtomicPredicate (
			sign <- ':',
			expression <- Sequence{objParam1, ext1} 
		),
		objParam1: AMN!Variable(name <- thisModule.firstParamOfObjectMethod),		
		ext1: AMN!NamedConstant(name <- 'ext_' + attr.attributeOf.name.amnId),
		anySubst1: AMN!Any(
			any <- outputPars->collect(p | p.outParamTempVarName),
			where <- whr1,
			thenPart <- simSubst1
		),
		whr1: AMN!Conjunction(
			predicate <- outputPars->collect(p | thisModule.resolveTemp(p, 'paramTyping1'))
		),
		simSubst1: AMN!Simultaneous(
			substitution <- outputPars->collect(p | thisModule.resolveTemp(p, 'assign1'))
		),
		skip: AMN!Identity
}

-- Parameter of functional attribute
rule Parameter{
	from p: Synthesis!ParameterDef
	to
		paramTyping: AMN!AtomicPredicate (
			sign <- ':',
			expression <- param
		),
		param: AMN!Variable(
			name <- if p.parameterKind = '+' 
					then p.name.amnId
					else p.outParamTempVarName
					endif
		),
		assign: AMN!BecomesEqual(
			leftExpression <- paramVar,
			rightExpression <- newParamVar
		),
		paramVar: AMN!Variable(name <- p.name.amnId),
		newParamVar: AMN!Variable(name <- p.outParamTempVarName),
		
		-- Copy of all staff for refined machine with empty operations 
		paramTyping1: AMN!AtomicPredicate (
			sign <- ':',
			expression <- param1
		),
		param1: AMN!Variable(
			name <- if p.parameterKind = '+' 
					then p.name.amnId
					else p.outParamTempVarName
					endif
		),
		assign1: AMN!BecomesEqual(
			leftExpression <- paramVar1,
			rightExpression <- newParamVar1
		),
		paramVar1: AMN!Variable(name <- p.name.amnId),
		newParamVar1: AMN!Variable(name <- p.outParamTempVarName)		
	do{
		thisModule.PutTypeToAtomicPredicate(p.type, paramTyping);
		thisModule.PutTypeToAtomicPredicate(p.type, paramTyping1);
	}
}

rule PutTypeToAtomicPredicate(type: Synthesis!TypeDef, ap: AMN!AtomicPredicate){
	do{
		if(type.oclIsKindOf(Synthesis!ADTDef))
			ap.expression <- thisModule.ADT_Typing(type);
		else 
		if(type.oclIsKindOf(Synthesis!IntegerDef))
			ap.expression <- thisModule.Integer_Typing(type);
		else 
		if(type.oclIsKindOf(Synthesis!BooleanDef))
			ap.expression <- thisModule.Boolean_Typing(type);
		else 
		if(type.oclIsKindOf(Synthesis!StringDef))
			ap.expression <- thisModule.String_Typing(type);
		else 
		if(type.oclIsKindOf(Synthesis!SetDef))
			ap.expression <- thisModule.Set_Typing(type);						
	}
}


-----------------------
-- HELPERS
-----------------------

helper context Synthesis!ModuleDef def: contextMachineName: String =
	if not (self.name.trim() = '')
	then self.name.amnId + '_Context'
	else 'Undefined_Context'
	endif
;

helper def: firstParamOfObjectMethod: String =
	'av'
;

helper context Synthesis!AttributeDef def: isMethod(): Boolean =					
	if not self.type.oclIsTypeOf(Synthesis!FunctionDef)
	then true
	else false
	endif
;

-- One-symbol ids are inappropriate for Atelier B.
-- They are transformed into two-symbol.
helper context String def: amnId: String =
	if self.size() = 1
	then self + self
	else self
	endif
;

helper context Synthesis!ParameterDef def: outParamTempVarName: String =
	self.name.amnId + '1'
;

helper context Synthesis!Variable def: tempVarName: String =
	self.name.amnId + '1'
;

helper context Synthesis!Atom def: isBuiltin: Boolean =
	if 	(	self.symbol = 'same' 
		or 	self.symbol = 'is_in'
		or  self.symbol = 'is_empty'
		)
	then true
	else false
	endif
;

helper context Synthesis!Atom def: isCollectionPredicate: Boolean =
	if 	Synthesis!ClassDef.allInstances()->collect(c | c.name)->includes(self.symbol)
		and self.terms->size() = 1 
		and self.terms->asSequence()->at(1).oclIsKindOf(Synthesis!Variable)
	then true
	else false
	endif
;

-- Arithmetic and set binary operators
helper context Synthesis!FunctionCall def: isBinaryOperator: Boolean =
	if 	self.name = '+' or 
		self.name = '-' or
		self.name = '*' or
		self.name = '%' or
		self.name = 'uni' or
		self.name = 'intersect' or
		self.name = 'differ'
	then true
	else false
	endif
;

-- Return predivative (function or invariant) which is specified 
-- by formula containing 'self' value.
helper context Synthesis!ValueDef def: specifies: Synthesis!Predicative =
	if not self.termOfAtom.oclIsUndefined()
	then self.termOfAtom.specifies
	else
		if not self.termOfCompoundValue.oclIsUndefined()
		then self.termOfCompoundValue.specifies
		else OclUndefined			
		endif		
	endif
;

-- Return predivative (function or invariant) which is specified 
-- by formula containing 'self' formula.
helper context Synthesis!Formula def: specifies: Synthesis!Predicative =
	if not self.specOf.oclIsUndefined()
	then self.specOf		
	else
		if not self.partOf.oclIsUndefined()
		then self.partOf.specifies		
		else
			if not self.comprehensionOf.oclIsUndefined()
			then self.comprehensionOf.specifies		
			else
				OclUndefined
			endif			
		endif
	endif
;

-- Simple path is of form v.a1. ... .an (v is a variable, ai are attribute names)
helper context Synthesis!NavigationPath def: isSimple: Boolean =
	self.terms->iterate(t; acc: Boolean = true |
		acc and (if t.oclIsKindOf(Synthesis!Variable) then true else false endif) )
;

-- Next two helpers return type of variable-term. 
-- Variable may be typed in quantified formula, collection comprehension or 
-- be a parameter of some predicative.
helper context Synthesis!ValueDef def: variableType(var: Synthesis!Variable): Synthesis!TypeDef =
	if var.name = 'this'
	then self.specifiesType
	else
		if self.oclIsKindOf(Synthesis!CollectionComprehension) 
		then 
			-- Variable is bounded by set comprehension
			if self.variables->collect(v | v.name)->includes(var.name)
			then self.variables->any(v | v.name = var.name).type
			else			
				if not self.termOfAtom.oclIsUndefined()
				then self.termOfAtom.variableType(var)
				else
					if not self.termOfCompoundValue.oclIsUndefined()
					then self.termOfCompoundValue.variableType(var)
					else OclUndefined			
					endif		
				endif			
			endif
		else
				if not self.termOfAtom.oclIsUndefined()
				then self.termOfAtom.variableType(var)
				else
					if not self.termOfCompoundValue.oclIsUndefined()
					then self.termOfCompoundValue.variableType(var)
					else OclUndefined			
					endif		
				endif		
		endif
	endif
;

helper context Synthesis!Formula def: variableType(var: Synthesis!Variable): Synthesis!TypeDef =
	if self.oclIsKindOf(Synthesis!QuantifiedFormula) 
	then 
		-- Variable is bounded by quantifier
		if self.variables->collect(v | v.name)->includes(var.name)
		then self.variables->any(v | v.name = var.name).type
		else
			-- SPECIFICATION-OF
			if not self.specOf.oclIsUndefined()
			then 
				if self.specOf.parameters->collect(v | v.name)->includes(var.name)
				then self.specOf.parameters->any(p | p.name = var.name).type
				else OclUndefined
				endif 			
			else		
					-- PART-OF, COMPREHENSION-OF
					if not self.partOf.oclIsUndefined()
					then self.partOf.variableType(var)		
					else
						if not self.comprehensionOf.oclIsUndefined()
						then self.comprehensionOf.variableType(var)		
						else OclUndefined
						endif			
					endif
			endif
		endif
	else
			-- SPECIFICATION-OF
			if not self.specOf.oclIsUndefined()
			then 
				if self.specOf.parameters->collect(p | p.name)->includes(var.name)
				then self.specOf.parameters->any(p | p.name = var.name).type
				else OclUndefined					
				endif 			
			else		
					-- PART-OF, COMPREHENSION-OF
					if not self.partOf.oclIsUndefined()
					then self.partOf.variableType(var)		
					else
						if not self.comprehensionOf.oclIsUndefined()
						then self.comprehensionOf.variableType(var)		
						else OclUndefined
						endif			
					endif
			endif
	endif
;

-- Returns type that is specified by some predicative containing self
helper context Synthesis!ValueDef def: specifiesType: Synthesis!TypeDef =
	let p: Synthesis!Predicative = self.specifies in 
	if(not p.oclIsUndefined())
	then 
		if(not p.typeOfAttribute.oclIsUndefined())
		then p.typeOfAttribute->any(a | a.oclIsKindOf(Synthesis!AttributeDef)).attributeOf
		else OclUndefined
		endif
	else OclUndefined
	endif
;

-- Search for the attr in adt and its supertypes.
-- Return a type of the attr or UNDEFINED if attr is not found.
helper context Synthesis!ADTDef def: hasAttribute(attrName: String): Synthesis!TypeDef =
	if self.attributes->collect(a | a.name)->includes(attrName)
	then self.attributes->any(a | a.name = attrName).type
	else
		self.supertypes->collect(t | t.hasAttribute(attrName))->any(t | not t.oclIsUndefined())
	endif
;


helper context Synthesis!ADTDef def: isSubtypeOf(sup: Synthesis!ADTDef): Boolean =
	if self = sup or self.supertypes->includes(sup)
	then true
	else  
		 self.supertypes->exists(t | t.isSubtypeOf(sup))		
	endif
;

helper context Synthesis!AttributeDef def: hasCardinality: Boolean =
	if(	(not self.type.oclIsKindOf(Synthesis!Predicative)) and
		(not self.cardinality.oclIsUndefined()) and
		self.type.oclIsKindOf(Synthesis!SetDef) )
	then self.cardinality > 0
	else false
	endif
;

helper context Synthesis!ADTDef def: isIstanceTypeOfAssociationMetaclass: Boolean =
	Synthesis!AssociationMetaclassDef.allInstances()->select(am | am.instanceType = self)->size() > 0
;

---------------------------
-- toString HELPERS
---------------------------

helper context Synthesis!Variable def: toString(): String =
	self.name
;

helper context Synthesis!NavigationPath def: toString(): String =
	if self.terms->size() > 0
	then
		let s: String = self.terms->iterate(i; acc : String = '' | acc + i.toString() + '.') in 
		s.substring(1, s.size() - 1)
	else 'EMPTY_PATH'		
	endif	
;

